---
title: "FutureTech Sales Acceleration Analytics Case"
format:
  dashboard:
    orientation: columns
    nav-buttons: [github]
    github: https://github.com/pmmagusiak/az_futuretech_case
    logo: images/logo.png
    theme: lux
server: shiny
---

```{r}
#| label: load-packages
#| context: setup
#| message: false

library(tidyverse)
library(skimr)
library(gt)
library(bslib)
library(ggimage)
library(DT)
library(shiny)
```

```{r}
#| label: load-data
#| context: setup
#| message: false

# Importing files into R environment

outreaches <- read_csv("data/contact_summary.csv")

sales <- read_csv("data/sales_summary.csv")
```

```{r}
#| label: initial-prep-data
#| context: setup
#| include: false
#| message: false

## Focusing on outreaches database

skim_without_charts(outreaches) # Using skimr package to summary data tables and overview missing values, duplicates and other information

outreaches |> filter(if_any(everything(), is.null)) # Checking if there are any rows with null values, as skimr does not assess that

outreaches |> 
  count(shop, Product, date) |> 
  filter(n > 1) # There were cases of more than 1 contact per day
  
outreaches_processed <- outreaches |>
  group_by(shop, Product, date) |> 
  mutate(contact_count = n()) |> # Column with a number of contacts per date
  ungroup() |> 
  arrange(date) |> 
  group_by(shop, Product) |> 
  mutate(first_contact = min(date), contact_window_start = date, contact_window_end = lead(date) - days(1)) |> # As there are sales that took place before first contact, a first contact column may prove useful
  mutate(contact_window_end = case_when(is.na(contact_window_end) ~ today(), TRUE ~ contact_window_end)) # Creating contact windows columns is crucial for further sales analysis
  
## Focusing on sales database, initial procedures the same as above

skim_without_charts(sales)

sales |> filter(if_any(everything(), is.null))

## Joining 

sales_before_first_contact <- sales |> 
  inner_join(outreaches_processed, join_by(shop, Product), suffix = c("_of_sell", "_of_previous_contact"), relationship = "many-to-many") |> 
  group_by(shop, Product) |> 
  filter(date_of_sell < first_contact & contact_window_start == first_contact) |> 
  mutate(date_of_previous_contact = NA_Date_, contact_window_start = NA_Date_, contact_window_end = NA_Date_, trigger = "Sales before first manufacturer contact") # There were 408 cases of items sold before first contact. I changed trigger label for the sake of future plot

sales_within_contact_window <- sales |> 
  inner_join(outreaches_processed, join_by(shop, Product), suffix = c("_of_sell", "_of_previous_contact"), relationship = "many-to-many") |> 
  group_by(shop, Product) |> 
  filter(date_of_sell >= contact_window_start & date_of_sell <= contact_window_end)  # Joining variables are shop and product, as there are the same amount of n_unique shop ids and product names in both dbases and shops are in center of my analysis; join type does not matter right now because of many-to-many relationship
  
futuretech <- sales_within_contact_window |> 
  bind_rows(sales_before_first_contact) |> 
  select(shop, location, product = Product, date_of_sell, units_sold, date_of_previous_contact, contact_count, first_contact, trigger) |> 
  mutate(product = factor(product), trigger = factor(trigger)) |> 
  mutate(image_url = case_when(product == "Badge of Courage" ~ "images/badge_of_courage.png", product == "Boots of Levitation" ~ "images/boots_of_levitation .png", product == "Cape of Velocity" ~ "images/cape_of_velocity.png", product == "Cloak of the Undead King" ~ "images/cloak_of_the_undead_king.png", product == "Elixir of Life" ~ "images/elixir_of_life.png", TRUE ~ "images/lions_shield_of_courage.png")) # Final database after wrangling, column tidying and adding images url

# My final database has about 60 observations less than raw database because it does not contain information about outreaches that took place after the last sell
```

```{r}
#| label: data-analysis
#| context: setup
#| include: false
#| message: false


sales2 <- sales |>
  group_by(shop, Product, date) |> 
  ungroup() |> 
  arrange(date) |> 
  group_by(shop, Product) |> 
  mutate(sales_window_start = lag(date) + days(1), sales_window_end = date)





futuretech |> 
  group_by(shop, trigger) |> 
  summarize(campaign_shop_sales = sum(units_sold))
  
futuretech |> 
  group_by(shop, date_of_previous_contact) |> 
  summarize(how_many_contacts = n_distinct(date_of_previous_contact))

futuretech |>
  group_by(shop) |>  
  mutate(total_contacts = n_distinct(date_of_previous_contact, na.rm = TRUE)) |> 
  ungroup() |> 
  distinct(shop, total_contacts) |> 
  count(total_contacts, sort = TRUE)

  
  # Distribution of total contacts count, based on this I can create additional categorical label, 

outreaches |> 
  group_by(shop) |>  
  mutate(total_contacts = n_distinct(date, na.rm = TRUE)) |> 
  ungroup() |> 
  distinct(shop, total_contacts) |> 
  count(total_contacts, sort = TRUE) |> 
  print(n = 25)

outreaches |> 
  group_by(shop) |> 
  distinct(date, .keep_all = TRUE) |> 
  count(shop, sort = TRUE) # In the original database there is more contacts! I made a mistake somewhere

  
  
  
  
  
  mutate(
    contact_category = case_when(
      total_contacts == 1 ~ "1 kontakt",
      total_contacts >= 2 & total_contacts <= 4 ~ "Od 2 do 4 kontaktów",
      total_contacts > 4 ~ "Więcej niż 4 kontakty",
      TRUE ~ "Brak danych"
    )
  )
✅ Option
                                  
  summarize(campaign_shop_sales = sum(units_sold), .groups = "drop") |> 
  group_by(trigger) |> 
  summarize(avg_campaign_shop_sales = mean(campaign_shop_sales), sd_campaign_shop_sales = sd(campaign_shop_sales), .groups = "drop") |> 
  ggplot(aes(x = reorder(trigger, avg_campaign_shop_sales), y = avg_campaign_shop_sales, fill = trigger)) +
  geom_col() +
  geom_errorbar(aes(ymin = avg_campaign_shop_sales - sd_campaign_shop_sales, ymax = avg_campaign_shop_sales + sd_campaign_shop_sales), width = 0.2) +
    labs(y = "Units sold", fill = "Campaign", caption = "Error bars represent ±1 standard deviation from the mean") +
    theme_light() + 
  theme(
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
    
  
  coord_flip()
  

  
futuretech |> 
  group_by(shop) |> 
  filter(date_of_sell < "2020-06-22", sum(units_sold) == 1) |> View() # We know from the initial prep that shops sold units from 2014-10-12 to 2024-01-08, median is 2020-06-22, let's dive into a group of shops which sold product long ago. 
 
```


# Analysis

## Sidebar {.sidebar}

```{r}
sliderInput("sales_range", "Filter shops by sales volume:", min = 1, max = 46, value = c(1, 46))
```

## Column - Value boxes and plots {width=55%}

### Row - Value boxes {height=16%}

```{r}
value_box(
  title = "Average shop sells",
  value = textOutput("mean"),
  theme = "light"
)
```

```{r}
value_box(
  title = "Total units sold",
  value = textOutput("total"),
  theme = "light"
)
```

### Row - Plot - Mean shop-level sales by engagement approach {height=40%}

```{r}
#| title: Mean shop-level sales by engagement approach

plotOutput("campaign")
```

### Row - Plot - Lollipop {height=44%}

```{r}
#| title: Which products sell the most?

plotOutput("lollipop")
```

## Column - Plot and table {width=45%}

### Row - Plot - Distribution of products sold {height=50%}

```{r}
#| title: Distribution of products sold
#| fig-width: 10

mean_items_sold <- futuretech |>
  group_by(shop) |> 
  summarize(sum = sum(units_sold)) |> 
  pull(sum) |> 
  mean() 

futuretech |>
  group_by(shop) |> 
  summarize(shop_sales_total = sum(units_sold)) |> 
  ggplot(aes(shop_sales_total)) +
  geom_histogram(binwidth = 1) +
  geom_vline(
    aes(xintercept = mean(shop_sales_total)),
    color = "#F8766D",
    linetype = "dashed",
    linewidth = 1
  ) +
  labs(
    x = "Units sold",
    y = "Count"
  ) +
  annotate(
    "text",
    x = mean_items_sold,
    y = Inf,
    label = paste("Mean =", round(mean_items_sold, 2)),
    vjust = 4,
    hjust = -0.1,
    color = "#F8766D"
  ) +
  theme_minimal() # Histogram of sales, very useful for choosing inputs on slider
```

### Row - Tabset of tables {height=50% .tabset}

```{r}
#| include: false
#| message: false

futuretech |> 
  count(shop, product)

n_distinct(futuretech$shop) # Those two lines of code prove that one shop bought only one type of product
```

```{r}
#| title: Top 20 sellers
#| fig-width: 10

futuretech |> 
  group_by(shop, product, location) |> 
  summarize(shop_sales_total = sum(units_sold), .groups = "drop") |> 
  arrange(desc(shop_sales_total)) |>
  slice_head(n = 20) |>
  select(Shop = shop, Location = location, Product = product, Sold = shop_sales_total) |>
  gt() |> 
  cols_align(align = "left", columns = Product) |> 
  tab_options(table.width = "95%")
```

```{r}
#| title: Bottom 20 sellers
#| fig-width: 10

futuretech |> 
  group_by(shop, product, location) |> 
  summarize(shop_sales_total = sum(units_sold), .groups = "drop") |> 
  arrange(shop_sales_total) |>
  slice_head(n = 20) |>
  select(Shop = shop, Location = location, Product = product, Sold = shop_sales_total) |>
  gt() |> 
  cols_align(align = "left", columns = Product) |> 
  tab_options(table.width = "95%")
```

# Data

```{r}
futuretech |> 
  select(-c(first_contact, image_url)) |> 
  datatable(colnames = c("date of sell" = "date_of_sell", "units sold" = "units_sold", "previous contact" = "date_of_previous_contact", "contact count" = "contact_count", "contact type" = "trigger"))
```

```{r}
#| context: server

# Basic filtering logic

futuretech_filtered <- reactive({
  futuretech |>
    group_by(shop) |> 
    filter(sum(units_sold) >= input$sales_range[1] & sum(units_sold) <= input$sales_range[2]) |> 
    ungroup()
})

# Value boxes code

average_shop_sales <- reactive({
  futuretech_filtered() |>
    group_by(shop) |> 
    summarize(sum = sum(units_sold)) |> 
    pull(sum) |> 
    mean()
})

output$mean <- renderText({
  round(average_shop_sales(), 2)
})

total_units_sold <- reactive({
  futuretech_filtered() |> 
    summarize(total = sum(units_sold)) |> 
    pull(total)
})

output$total <- renderText({
  total_units_sold()
})

# top_selling_product <- reactive({
#   futuretech_filtered() |> 
#     group_by(product) |>
#     summarize(total_product_sold = sum(units_sold)) |> 
#     arrange(desc(total_product_sold)) |> 
#     slice_head(n = 1) |> 
#     pull(product) |> 
#     as.character()
# })
# 
# output$top_seller <- renderText({
#   top_selling_product()
# })

# Code for an interactive lollipop plot

output$lollipop <- renderPlot({
  futuretech_filtered() |> 
  group_by(product) |>
  summarize(total_product_sold = sum(units_sold), image_url = first(image_url)) |> 
  ggplot(aes(x = reorder(product, total_product_sold, decreasing = TRUE)), y = total_product_sold) +
    geom_segment(aes(xend = product, y = 0, yend = total_product_sold, linewidth = "10px"), color = "gray", show.legend = FALSE) +
    geom_image(aes(image = image_url, y = total_product_sold), size = .15) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.15))) + # I am using this line so that my top image is fitting to plot
    ylab("Units sold") +
    theme_light() +
    theme(axis.title.x = element_blank())
})

# Code for an interactive campaign effectiveness plot

output$campaign <- renderPlot({
  futuretech_filtered() |> 
  group_by(shop, trigger) |> 
  summarize(campaign_shop_sales = sum(units_sold), .groups = "drop") |> 
  group_by(trigger) |> 
  summarize(avg_campaign_shop_sales = mean(campaign_shop_sales), sd_campaign_shop_sales = sd(campaign_shop_sales), .groups = "drop") |> 
  ggplot(aes(x = reorder(trigger, avg_campaign_shop_sales), y = avg_campaign_shop_sales, fill = trigger)) +
  geom_col() +
  geom_errorbar(aes(ymin = avg_campaign_shop_sales - sd_campaign_shop_sales, ymax = avg_campaign_shop_sales + sd_campaign_shop_sales), width = 0.2) +
    labs(y = "Units sold", fill = "Campaign", caption = "Error bars represent ±1 standard deviation from the mean") +
    theme_light() + 
  theme(
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
    
  
  coord_flip()
})
```
