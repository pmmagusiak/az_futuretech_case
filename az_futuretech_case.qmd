---
title: "FutureTech Sales Acceleration Analytics Case"
format:
  dashboard:
    nav-buttons: [github]
    github: https://github.com/pmmagusiak/az_futuretech_case
server: shiny
---

```{r}
#| label: load-packages
#| context: setup
#| message: false

library(tidyverse)
library(skimr)
library(ggimage)
library(shiny)
```

```{r}
#| label: load-data
#| context: setup
#| message: false

# Importing files into R environment

outreaches <- read_csv("data/contact_summary.csv")

sales <- read_csv("data/sales_summary.csv")
```

```{r}
#| label: initial-prep-data
#| context: setup
#| include: false
#| message: false

## Focusing on outreaches database

skim_without_charts(outreaches) # Using skimr package to summary data tables and overview missing values, duplicates and other information

outreaches |> filter(if_any(everything(), is.null)) # Checking if there are any rows with null values, as skimr does not assess that

outreaches |> 
  count(shop, Product, date) |> 
  filter(n > 1) # There were cases of more than 1 contact per day
  
outreaches_processed <- outreaches |>
  group_by(shop, Product, date) |> 
  mutate(contact_count = n()) |> # Column with a number of contacts per date
  ungroup() |> 
  arrange(date) |> 
  group_by(shop, Product) |> 
  mutate(first_contact = min(date), contact_window_start = date, contact_window_end = lead(date) - days(1)) |> # As there are sales that took place before first contact, a first contact column may prove useful
  mutate(contact_window_end = case_when(is.na(contact_window_end) ~ today(), TRUE ~ contact_window_end)) # Creating contact windows columns is crucial for further sales analysis
  
## Focusing on sales database, initial procedures the same as above

skim_without_charts(sales)

sales |> filter(if_any(everything(), is.null))

## Joining 

sales_before_first_contact <- sales |> 
  inner_join(outreaches_processed, join_by(shop, Product), suffix = c("_of_sell", "_of_previous_contact"), relationship = "many-to-many") |> 
  group_by(shop, Product) |> 
  filter(date_of_sell < first_contact & contact_window_start == first_contact) |> 
  mutate(date_of_previous_contact = NA_Date_, contact_window_start = NA_Date_, contact_window_end = NA_Date_, trigger = NA) # There were 408 cases of items sold before first contact

sales_within_contact_window <- sales |> 
  inner_join(outreaches_processed, join_by(shop, Product), suffix = c("_of_sell", "_of_previous_contact"), relationship = "many-to-many") |> 
  group_by(shop, Product) |> 
  filter(date_of_sell >= contact_window_start & date_of_sell <= contact_window_end)  # Joining variables are shop and product, as there are the same amount of n_unique shop ids and product names in both dbases and shops are in center of my analysis; join type does not matter right now because of many-to-many relationship
  
futuretech <- sales_within_contact_window |> 
  bind_rows(sales_before_first_contact) |> 
  select(shop, product = Product, date_of_sell, units_sold, date_of_previous_contact, contact_count, first_contact, trigger) |> 
  mutate(image_url = case_when(product == "Badge of Courage" ~ "images/badge_of_courage.png", product == "Boots of Levitation" ~ "images/boots_of_levitation .png", product == "Cape of Velocity" ~ "images/cape_of_velocity.png", product == "Cloak of the Undead King" ~ "images/cloak_of_the_undead_king.png", product == "Elixir of Life" ~ "images/elixir_of_life.png", TRUE ~ "images/lions_shield_of_courage.png")) # Final database after wrangling, column tidying and adding images url

# My final database has about 60 observations less than raw database because it does not contain information about outreaches that took place after the last sell
```

```{r}
#| label: data-analysis
#| context: setup
#| include: false
#| message: false

mean_items_sold <- futuretech |> # Needed later on
  group_by(shop) |> 
  summarize(sum = sum(units_sold)) |> 
  pull(sum) |> 
  mean() 

futuretech |> 
  group_by(product, units_sold) |> 
  count() |> 
  summarize(total_products = units_sold * n, .groups = "drop") |> 
  group_by(product) |> 
  summarize(total = sum(total_products))

futuretech |> 
  group_by(product) |> 
  summarize(sum = sum(units_sold))

successful <- futuretech |> 
  group_by(shop) |> 
  filter(sum(units_sold) > 16)
  
successful |> 
  group_by(product) |> 
  count()

successful |> 
  group_by(shop, trigger) |> 
  summarize(total_shop_sales_during_campaign = sum(units_sold), .groups = "drop") |> 
  group_by(trigger) |> 
  summarize(avg_sales_during_campaign = mean(total_shop_sales_during_campaign), sd_sales_during_campaign = sd(total_shop_sales_during_campaign), .groups = "drop") |> 
  ggplot(aes(x = reorder(trigger, avg_sales_during_campaign), y = avg_sales_during_campaign, fill = trigger)) +
  geom_col() +
  geom_errorbar(aes(ymin = avg_sales_during_campaign - sd_sales_during_campaign, ymax = avg_sales_during_campaign + sd_sales_during_campaign), width = 0.2) +
  labs(title = "Average Sales per Shop by Outreach Strategy") +
  coord_flip()






futuretech_campaign_analysis <- futuretech |> 
  group_by(shop, trigger) |> 
  summarize(campaign_shop_sales = sum(units_sold), .groups = "drop") |> 
  group_by(trigger) |> 
  summarize(avg_campaign_shop_sales = mean(campaign_shop_sales), sd_campaign_shop_sales = sd(campaign_shop_sales), .groups = "drop")


ggplot(futuretech_campaign_analysis, aes(x = reorder(trigger, avg_sales_during_campaign), y = avg_sales_during_campaign, fill = trigger)) +
  geom_col() +
  geom_errorbar(aes(ymin = avg_sales_during_campaign - sd_sales_during_campaign, ymax = avg_sales_during_campaign + sd_sales_during_campaign), width = 0.2) +
  labs(title = "Average Sales per Shop by Outreach Strategy") +
  coord_flip()



```

```{r}
#| label: data-visualisation
#| context: setup
#| include: false
#| message: false
```

# Plots

# {.sidebar}

```{r}
sliderInput("items", "Filter shops by sales volume:", min = 1, max = 46, value = c(1, 46))
```

## Value boxes {height="20%"}

## Plots {height="80%"}

### 1st row of plots 

```{r}
#| title: Working title

futuretech |>
  group_by(shop) |> 
  summarize(shop_sales_total = sum(units_sold)) |> 
  ggplot(aes(shop_sales_total)) +
  geom_histogram(binwidth = 1) +
  geom_vline(
    aes(xintercept = mean(shop_sales_total)),
    color = "red",
    linetype = "dashed",
    linewidth = 1
  ) +
  labs(
    title = "Distribution of Items Sold",
    x = "Items Sold",
    y = "Count"
  ) +
  annotate(
    "text",
    x = mean_items_sold,
    y = Inf,
    label = paste("Mean =", round(mean_items_sold, 2)),
    vjust = 4,
    hjust = -0.1,
    color = "red"
  ) +
  theme_minimal() # Histogram of sales, very useful for choosing inputs on slider, mean is 8.49

# zastrzeżenie że też przed oknem marketingowym te rzeczy, mozesz zrobic disclaimer
```

```{r}
#| title: Working title
```

### 2nd row of plots

```{r}
#| title: Working title
```

# Data

```{r}
filtered_data <- reactive({
  df %>% filter(units_sold >= input$min_sales)
})

output$lollipopPlot <- renderPlot({
  ggplot(filtered_data(), aes(x = reorder(product, units_sold), y = units_sold)) +
    geom_segment(aes(xend = product, y = 0, yend = units_sold), color = "gray") +
    geom_image(aes(image = image_url), size = 0.07) +
    coord_flip() +
    labs(x = "Product", y = "Units Sold")
})
```

